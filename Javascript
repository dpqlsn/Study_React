# Javascript

01. Javascript : 동적기능 및 언어의 일부
02. Javascript를 배워야 하는 이유 : 방대한 라이브러리와 프레임워크가 있고 **쉽다**.

    **문서로 먼저 만들어지는 것이 JS**

### 상수의 종류

01. const 
→ 변수 다시 재할당 불가능, 코드를 **항상 유지** 하고 싶을 때 사용하는 상수 (불변)

02. let
→ 재할당이 가능, 대체적으로 **for 문**에 사용 (불변)

03. var
→ 한번 선언 후 초기화, 다른 선언 후 초기화해도 에러가 나지 않음 **단, 옛날문법이라 잘안씀**

### 변수 타입

00. 집합
→ 동일한 속성이나 특징을 가진 원소들을 묶은 것

01. Number
→ 숫자에 하나의 형식, 따로 선언하지 않아도 됨
02. String
→ 문자열의 길이에는 상관 없이 값 저장, 한번 정의한 문자열은 변하지 않음
03. Boolean
→ 값은 true, false만을 나타냄
04. Null
: 의도적으로 변수에 값이 없다는 것을 명시할 때 사용
  없다는 의미로 의도적으로 값이 없을 때 사용하는 것, 값을 체크하기 위해서 **===** 사용

5 == `5` // 변수값을 기반으로 비교
5 === `5` // 변수값과 문자열의 종류가 모두 같은지를 비교함, 같으면 true 다르면 false

05. Undefined
→ 선언 이후 값을 할당하지 않은 변수가 가지는 값으로 없다는 의미로 선언만 하고 초기화를 안함

06. **Symbol**
→ 변경 불가능한 원시 타입의 값으로 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용합니다.

**문자열에서는 반드시 “” 를 사용해야지 에러가 나지 않음**

07. 원시형 타입
→ 기본형 타입으로 불라고 프로그래밍에 있어서 가장 기본적인 값들의 타입을 의미함
  ex ) Number, String, boolean, Null, undefinded

08. 객체 타입
→ 기본형 타입의 반대 개념으로 생각하면 편함
  ex ) object → array, Function, Regexexp

### 연산자

01. 산술연산자

let value = 5;
console.log(++value); //값 증가 후 출력 > 6
console.log(value++); //출력 후 값 증가 > 5

console.log(+value); //값 상태변환 안함
console.log(value+); //양수면 음수로, 음수면 양수로

02. 할당연산자

let num = 5;
num += 5;
num + num+5;

03. 비교연산자

1. >         2. <       3. >=        4. <=

04. 동등연산자

1. a==b      2. a!=b //!는 보통 반대의 의미를 가짐

05. 삼항연산자

**기본구조 → 조건문 ? 참 : 거짓**

let a = 5;
let b = 11;
console.log((a>b) ? "a가 더 크다" : "b가 더 크다");

06. 이진 논리 연산자

1. a && b : a와 b가 모두 true일 경우에만 true
2. a || b : a와 b 중 하나만 true도 true값을 가짐

07. 일치연산자

a !== b //a가 b와 값이나 자료형이 같지 않다
a === b //a가 b와 값과 자료형이 모두 같다

### 함수

01. 다른 객체처럼 속설 및 method를 가질 수 있음, **자체적인 범위**
입력을 받아서 정해진 출력을 하는 것
2. 코드를 재사용 하기 위하여
→ 동일한 코드를 여러번 사용 가능하고 다른 결과를 도출함
    1. 변수 안에 담김
    2. 객체의 속성 method를 담길 수 있음
    3. 배열값 사용

02. arrow 함수 (화살표 함수)
→ 항상 익명이므로 알 수 없는 함수, 일반 함수와 달리 this를 가지지 않기 떄문에 화살표 함수 내부에서 this를 사용하면 외부의 값을 가져옴

{} < 을 쓰면 return 사용
{} < 을 쓰지 않으면 undefind 반환
{} < 을 사용할 때는 여러줄을 씀

03. 배열
: 어떤 한가지 자료형을 연속적으로 나열하는 것

let a[5] = {1, 2, 3, 4, 5};


### 객체

01. 여러 속성을 하나의 변수애 저장, key 와 value 한번에 저장 가능
02. key는 고유한 값

const person = {
	name : 'Yebeen'; //이때 name는 key, 'Yebeen'은 value
}

1. 객체는 변수, 많은 값을 포함
2. 객체변수를 복사하면 참조가 복사, 객체 복사는 안됨
3. 객체의 종류 : 배열, 함수, 객체, 수학, 날짜, 숫자, 문자열, boolean 등등

### 내장객체

01. JS 안에서 만들어짐, 브라우저에서 JS 코드를 해석하고 실행하는 'JavaScript 엔진'에 포함
ex ) string, boolean, date, arrow, math 등등

console.log(str.length);
console.log(str.toupper);

02. 브라우저 내장객체
    1. BOM : 브라우저 창과 관현된 객체 제공
    2. **DOM** : 웹페이지의 구조를 표현하는 객체 모델 즉, 웹 API까지 접근 가능, 동작조정가능
                html의 작은 요소까지 접근 가능, 부모와 자식 관계
                JS는 스크립트 경로에 DOM은 수정 가능하지만 프로그래밍 언어는 불가능

03. 사용자 정의 객체
: 생성자 힘수 또는 객체 리터럴을 사용해 사용자가 객체 정의 후 실행

웹요소 내용 수정
innerText, innerHTML

### Callback Function ( 콜백함수 )

01. 비동기 문법, 보통 백엔드랑 연결될 때 사용

let num = {1, 2, 3, 4, 5};
num forthach ( x== {
	console.log(x+2);	
};
// 함수 내부에서 실행되는 익명함수 이므로 이름을 붙이지 않아도 됨, Function 붙이기!


02. 함수 이름 넘기기
→ null 과 indefined를 제외한 모든 것을 객체로 다룸
03. 전역변수
→ 함수 외부에서 선언되는 변수
04. 지역변수
→ 함수 내부에서 선언된 변수

### Callback 지옥

1. promise 를 사용하여 탈출가능 하지만 하나의 단계일 뿐이지만 promise + return 을 사용해 탈출가능
→ promise 를 반환해서 미래에 어떤 시점의 결과 제공
2. promise 
→ 어떤 작업에 관한 상태정보를 가지고 있는 객체 (보통 백엔드에서 관리)
    ex ) 인증문자를 받을 때 시간단위로 관리할 때 사용
        1. 비동기식 작업 순차적으로 진행하기 위해 사용, callback을 보기 좋게 하기 위해
        2. 비동기작업을 가능하게 하는 것은 아님!
        3. **resolve** : promise 객체 fulfilled 상태 함수 연결
        4. **reject** : promise 객체 rejected 상태 함수 연결

### Asyns, Await

01. 동기 : 어떤 작업을 실행할 때, 그 작업이 끝나기를 기다리는 방식
        → 코드 실행을 멈추고 기다림
02. **비동기** : 어떤 작업을 실행할 때, 그 작업이 완료되지 않아도 코드 실행하는 방식
            → 결과를 기다리지 않음
03. 비동기 처리를 하는 이유
→ 어떤 작업이 완료될 때까지 다른 작업을 못하기 때문에 비동기 처리를 함

1. 반응성 향상
2. 네트워크 통신
3. 병렬처리 (시간단축)
4. 에러처리

01. Asyns
→ 함수의 앞에 붙어서 해당 함수가 비동기 함수임을 나타냄
02. Await
→ Await의 키워드는 promise 객체가 완료될 때까지 코드 실행을 중지함